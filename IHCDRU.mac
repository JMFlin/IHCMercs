|- IHCBST.mac - By IHC385
|- Automatic Druid bot - 
|- Version 2.0
|- Updated: 4/25/2019
|- Credit: Toots, Noobhax0r, Maskoi, Ctaylor, Treehuggindruid. A lot of ideas were borrowed and modified from their macros
#Chat group
#Chat tell
#Chat raid
#turbo 80
#include IHCMercs\ihcsubs.inc
#include IHCMercs\ihcdruutil.inc
#include IHCMercs\ihcevents.inc
#warning
#bind SetVarInt	/setvarint
#bind CmdList        /ihchelp

Sub Main
	/delay ${Math.Rand[10]}
	/doevents flush
	/declare MacroName       	string outer IHCWAR
	/declare MacroPath       	string outer IHCMercs\IHCWAR
	/declare IHCVersion       	string outer 2.0 
	/declare IniFileName     	string outer ${MacroPath}_${EverQuest.Server}_${Me.CleanName}.ini

	/call DruSetup
	/call VarSetup
	/call SetupSpells
	/call LoadSpellBar

|-Cursor ID
	/if (${Cursor.ID}) {
		/echo Sending Item on Cursor to Bag
		/autoinventory
	}
	/call WelcomeMsg
	/declare AssistRange int outer 10
	/declare AutoCampRadius int outer 10
 :mainloop
	/call ModeSet
	/if (${Mode}==0) /call Travel
	/if (${Mode}==1) /call ManualPullCamping
	/if (${Mode}==2) /call ManualRunAndGun
	/if (${Mode}==3) /call ManualPullCamping
	/if (${Mode}==4) /call AFKRunAndGun
	/if (${Mode}==5) /call DoEvent
 /goto :mainloop
/return
|----------------------------------------------------------------------------
|- SUB: ManualPullCamping
|---------------------------------------------------------------------------- 
Sub ManualPullCamping
	/call MakeCamp
    /call RemoveTravelBuffs  

	/while (${Mode}==1 || ${Mode}==3) {
		/call check_state FALSE
		/call single_target_heals
		/call group_heals
		/call combat
|		/call check_for_corpse FALSE
		/call group_buffs

		/call MoveToCamp ${PullAutoCampX} ${PullAutoCampY} ${PullAutoCampZ} ${AutoCampRadius}

|		/doevents
	}
/return
|----------------------------------------------------------------------------
|- SUB: combat 
|---------------------------------------------------------------------------- 
Sub combat
	/if (!${Me.XTarget}) /return
	/call get_target
	/if (!${Target.ID}) /return

	/if (!${Target.Snared.ID}) {
		/if (${validate_cast[FALSE, spell, "${SnareSpell}", ${Target.ID}]}) /call core_cast2 "${SnareSpell}" spell ${Target.ID} FALSE
	}

	/if (${Me.PctMana} < 85) /return
	
	/call single_target_heals

	/if (!${Target.Buff[${DoTSpell1}].ID}) {
		/if (${validate_cast[FALSE, spell, "${DoTSpell1}", ${Target.ID}]}) /call core_cast2 "${DoTSpell1}" spell ${Target.ID} FALSE
	}

	/call single_target_heals

	/if (${validate_cast[FALSE, spell, "${NukeSpell1}", ${Target.ID}]}) /call core_cast2 "${NukeSpell1}" spell ${Target.ID} FALSE

/return
|----------------------------------------------------------------------------
|- SUB: debuff_xtarget
|---------------------------------------------------------------------------- 
Sub debuff_xtarget
	/declare x int local 1

	/if (!${Me.XTarget}) /return

	/for x 1 to ${Me.XTarget}

		/target id ${Me.XTarget[${x}].ID}
		/delay 1s ${Me.XTarget[${x}].ID} == ${Target.ID}
		
		/delay 1s

		/if (${Target.Distance} > 200) /return
		/if (!${Target.Type.Equal[NPC]}) /return
		
		| How will you handle the AA?
		/if (!${Target.Buff[${FireAtkDebuff}].ID}) {
			/docommand /dgt Attack debuff \ar ${Target.Name} \ax with =>> \ag ${FireAtkDebuff} \ax <<=
			/if (${validate_cast[FALSE, spell, "${FireAtkDebuff}", ${Target.ID}]}) /call core_cast2 "${FireAtkDebuff}" spell ${Target.ID} FALSE
		}

		/call single_target_heals

		/if (!${Target.Buff[${FireAcDebuff}].ID}) {
			/docommand /dgt Ac debuff \ar ${Target.Name} \ax with =>> \ag ${FireAtkDebuff} \ax <<=
			/if (${validate_cast[FALSE, spell, "${FireAcDebuff}", ${Target.ID}]}) /call core_cast2 "${FireAcDebuff}" spell ${Target.ID} FALSE
		}
		/delay 1s
	/next x
/return
|----------------------------------------------------------------------------
|- SUB: group_buffs
|---------------------------------------------------------------------------- 
Sub group_buffs
	/declare bmember			int local 0
	/declare CastCheck			int local 0
	/if (${SpawnCount[pccorpse group radius ${setMaxRezRange}]}) /return
	/if (${SpawnCount[pccorpse raid radius ${setMaxRezRange}]}) /return
	/if (${Me.Casting.ID}) /return

	/if (${Me.XTarget}) /return

	/for bmember 0 to ${Group}
		/if (${Group.Member[${bmember}].Distance}<${Spell[${Skin}].MyRange} && !${Group.Member[${bmember}].OtherZone}) {

			/if (${Group.Member[${bmember}].Type.Equal[Corpse]}) /continue
			/if (${Me.XTarget}) {
				/call LoadSpellBar
				/return
			}
			/if (${Mode} !=3 ) /return

			/if (!${Me.Book[${GroupSkin}]}) {
				
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Buff[${Skin}].ID" "tmpbuffid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Skin.ID" "tmpskinid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Symbol.ID" "tmpsymbolid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Aego.ID" "tmpaegoid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Spell[${Skin}].Stacks" "tmpstackcheck" "bool"
				/if (${tmpstackcheck} && !${tmpaegoid} && !${tmpbuffid} && ${Me.Book[${Skin}]} && ${Me.CurrentMana}>${Spell[${Skin}].Mana} && !${Me.Casting.ID}) {
					/if (${validate_cast[FALSE, spell, ${Skin}, ${Group.Member[${bmember}].ID}]}) /call core_cast2 "${Skin}" spell ${Group.Member[${bmember}].ID} FALSE
					/varset CastCheck 1
				}

			} else {
			
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Buff[${GroupSkin}].ID" "tmpbuffid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Skin.ID" "tmpskinid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Symbol.ID" "tmpsymbolid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Aego.ID" "tmpaegoid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Spell[${GroupSkin}].Stacks" "tmpstackcheck" "bool"
				/if (${tmpstackcheck} && !${tmpaegoid} && !${tmpbuffid} && ${Me.Book[${GroupSkin}]} && ${Me.CurrentMana}>${Spell[${GroupSkin}].Mana} && !${Me.Casting.ID}) {
					/echo ${Group.Member[${bmember}].Name} does not have aego in tmpbuffid ${tmpbuffid} and aegoid ${tmpaegoid}
					/if (${validate_cast[FALSE, spell, ${GroupSkin}, ${Group.Member[${bmember}].ID}]}) /call core_cast2 "${GroupSkin}" spell ${Group.Member[${bmember}].ID} FALSE
					/varset CastCheck 1
				}
			}
			/sit
			/if (${Me.CurrentMana}>${Spell[${SoW}].Mana} && ${Me.Book[${SoW}]}) {
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Buff[${SoW}].ID" "tmpbuffid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Spell[${SoW}].Stacks" "tmpstackcheck" "bool"
				/if (!${tmpbuffid} && ${tmpstackcheck}) {
					/if (${validate_cast[FALSE, spell, ${SoW}, ${Group.Member[${bmember}].ID}]}) /call core_cast2 "${SoW}" spell ${Group.Member[${bmember}].ID} FALSE
					/varset CastCheck 1
				}
			}
			
			/if (${Me.CurrentMana}>${Spell[${DamageShield}].Mana} && ${Me.Book[${DamageShield}]}) {
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Me.Buff[${DamageShield}].ID" "tmpbuffid" "int"
				/call Gquery ${EverQuest.Server.Lower}_${Group.Member[${bmember}].Name.Lower} "Spell[${DamageShield}].Stacks" "tmpstackcheck" "bool"
				/if (!${tmpbuffid} && ${tmpstackcheck}) {
					/if (${validate_cast[FALSE, spell, ${DamageShield}, ${Group.Member[${bmember}].ID}]}) /call core_cast2 "${DamageShield}" spell ${Group.Member[${bmember}].ID} FALSE
					/varset CastCheck 1
				}
			}
			/sit
		}
	/next bmember
	|- Delete variable's
	/if (${Defined[tmpbuffid]}) /deletevar tmpbuffid
	/if (${Defined[tmpskinid]}) /deletevar tmpskinid
	/if (${Defined[tmpsymbolid]}) /deletevar tmpsymbolid
	/if (${Defined[tmpaegoid]}) /deletevar tmpaegoid
	/if (${Defined[tmpstackcheck]}) /deletevar tmpstackcheck

	/if (${CastCheck}) {
		/call LoadSpellBar
		/docommand /dgt \aw Done Buffing
	}

/return
|----------------------------------------------------------------------------
|- SUB: HealGroup
|---------------------------------------------------------------------------- 
Sub single_target_heals
	/declare worsthurtid 		int local 0
	/declare gmember			int local 0

	| This only checks pcs
	/if (${Spawn[${WorstHurt[group,1,200,FALSE]}].Type.NotEqual[Corpse]} && ${Spawn[${WorstHurt[group,1,200,FALSE]}].PctHPs} < 75) {

		/varset worsthurtid ${Spawn[${WorstHurt[group,1,200,FALSE]}].ID}

		/if (${validate_cast[FALSE, spell, "${HealSpell1}", ${worsthurtid}]}) {
			/call core_cast2 "${HealSpell1}" spell ${worsthurtid} FALSE
		}
	}

	| Includes mercs
	/for gmember 0 to ${Group}
		
		/if (${Group.Member[${gmember}].Type.Equal[Corpse]}) /continue
		
		/if (${Group.Member[${gmember}].Distance} <= 200 && ${Group.Member[${gmember}].PctHPs} < 75) {
			/if (${validate_cast[FALSE, spell, "${HealSpell1}", ${Group.Member[${gmember}].ID}]}) {
				/call core_cast2 "${HealSpell1}" spell ${Group.Member[${gmember}].ID} FALSE
			}
        }

	/next gmember

/return
|----------------------------------------------------------------------------
|- SUB: HealGroup
|---------------------------------------------------------------------------- 
Sub group_heals
	/declare gmember			int local 0
	/declare HurtMember     	int local 0
	
	/if (${Me.PctHPs} <= 80) {
		/varcalc HurtMember ${HurtMember}+1
	}

   	/for gmember 1 to ${Group}
		
		/if (${Group.Member[${gmember}].Type.Equal[Corpse]}) /continue
		
		/if (${Group.Member[${gmember}].Distance} <= 200 && ${Group.Member[${gmember}].PctHPs} < 80) {
			/varcalc HurtMember ${HurtMember}+1
        }

	/next gmember

	/if (${HurtMember} >= 3) {
		/if (${validate_cast[FALSE, spell, "${GroupHealSpell1}", ${Me.ID}]}) /call core_cast2 "${GroupHealSpell1}" spell ${Me.ID} FALSE
	}

/return
	